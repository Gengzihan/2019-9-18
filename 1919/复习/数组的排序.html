<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <button id="up">升序</button>
    <button id="down">降序</button>
</body>

</html>
<script>

    var ary = [
        {
            name: 123,
            age: 12
        },
        {
            name: 1234,
            age: 10
        },
        {
            name: 12345,
            age: 122
        },
        {
            name: 123456,
            age: 102
        },
    ];

    ary.sort((a, b) => {
        return a.age - b.age;
    })
    var up = document.getElementById('up'),
        down = document.getElementById('down');
    up.onclick = function () {
        ary.sort((a, b) => {
            return a.age - b.age;
        })
        console.log(ary)
    }
    down.onclick = function () {
        ary.sort((a, b) => {
            return b.age - a.age;
        })
        console.log(ary)
    }

    //冒泡  排序
    //两两比较  大的在前边   小的在后边  一轮
    //正常  进行  ary.length轮
    function mySort1(arr) {
        for (var i = 0; i < arr.length; i++) {
            //轮数
            //每一轮都要进行两两比较
            for (var j = 0; j < arr.length - 1 - i; j++) {
                //前一项就是   前一项arr[]     后一项arr[+1]
                //第一项的索引是0  最后一项索引是length-1;  最后一项的后一项的索引是 length
                //但是数组中没索引是  length的这一项  所以我们循环是的最后一项
                //索引应该是  length-1
                if (arr[j] > arr[j + 1]) {
                    var temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        return arr;
    }
    var ary = [234, 456, 789, 987, 654, 321, 432, 654, 90];
    console.log(mySort1(ary));

    //快速排序
    //递归的思想   函数内部自已调用的自已  需要注意边界问题
    function f() {
        f()
    }
    //0-100之间  所有数字之和
    function sum(n) {
        // //边界
        // if (n >= 0) {
        //     return 0
        // }
        // return n+sum(n-1)

        if (n >= 0) {
            return n + sum(n - 1)
        }
        return 0
    }
    sum(100);//5050

    //0 -100  3的倍数或者5的倍数
    function sum2(n) {
        //边界
        if (n <= 0) {
            return 0
        }
        if (n % 3 == 0 || n % 5 == 0) {
            return n + sum2(n - 1)
        }
        return 0 + sum2(n - 1)
    }
    sum2(100)

    //0 -100 3的倍数之和
    function sum3(n) {
        //边界
        if (n <= 0) {
            return 0
        }
        if (n % 3 == 0 || n % 5 == 0) {
            return n + sum2(n - 1)
        }
        return 0 + sum3(n - 1)
    }


    //快速排序的思想
    //一直进行  把数组拆成三部分 中间一项  左边一个数组(小项)  右边一个数组(大项)
    //直到数组为空  或者数组只有一项的时候停止;
    function mySort2(arr) {
        if (arr.length <= 1) {
            //若数组是个空数组  或者数组中  只有一项的情况  就不用在进行拆分进行比较
            return arr;
        }
        var n = parseInt(arr.length / 2);//获取中间项的索引
        var temp = arr.splice(n, 1)[0];
        var let = [], right = [];
        arr.forEach((v, i) => {
            if (v > temp) {
                rigth.push(v)
            } else {
                left.push(v)
            }
        })
        // return left.concat(temp,right)
        return mySort2(left).concat(temp, mySort2(right))
    }
    var ary = [123, 456, 789, 234, 765, 865, 467, 347, 90]
    console.log(mySort2(ary))

    //arguments  this  形参实参   剩余运算符...
    function fn(a, b) {
        //es6  之前给  形参赋予默认值的方式
        a = a || 0;
        b = b || 0
        return a + b
    }
    function fn2(a=0,b=0){
        //es6  的形参赋予默认值
        return a+b
    }
    fn(2)
    console.log(fn2(6))
</script>